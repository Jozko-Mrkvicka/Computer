idx = 1;
LOOP_ =            bitor(c.LABEL_DEST_PREFIX, idx);
LOOP  =            bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
LEFT_ =            bitor(c.LABEL_DEST_PREFIX, idx);
LEFT  =            bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
RIGHT_ =           bitor(c.LABEL_DEST_PREFIX, idx);
RIGHT  =           bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
UP_ =              bitor(c.LABEL_DEST_PREFIX, idx);
UP  =              bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DOWN_ =            bitor(c.LABEL_DEST_PREFIX, idx);
DOWN  =            bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
FNC_READ_KEY_ =    bitor(c.LABEL_DEST_PREFIX, idx);
FNC_READ_KEY  =    bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
FNC_ERASE_SCR_ =   bitor(c.LABEL_DEST_PREFIX, idx);
FNC_ERASE_SCR  =   bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
UPROW_ =           bitor(c.LABEL_DEST_PREFIX, idx);
UPROW  =           bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
UPCOL_ =           bitor(c.LABEL_DEST_PREFIX, idx);
UPCOL  =           bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DNROW_ =           bitor(c.LABEL_DEST_PREFIX, idx);
DNROW  =           bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DNCOL_ =           bitor(c.LABEL_DEST_PREFIX, idx);
DNCOL  =           bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
CONTINUE_ =        bitor(c.LABEL_DEST_PREFIX, idx);
CONTINUE  =        bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
FNC_INIT_SNAKE_ =  bitor(c.LABEL_DEST_PREFIX, idx);
FNC_INIT_SNAKE  =  bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
FNC_DRAW_SNAKE_ =  bitor(c.LABEL_DEST_PREFIX, idx);
FNC_DRAW_SNAKE  =  bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
FNC_ERASE_SNAKE_ = bitor(c.LABEL_DEST_PREFIX, idx);
FNC_ERASE_SNAKE  = bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DRAW_LOOP_ =       bitor(c.LABEL_DEST_PREFIX, idx);
DRAW_LOOP  =       bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
ERASE_LOOP_ =      bitor(c.LABEL_DEST_PREFIX, idx);
ERASE_LOOP  =      bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
FNC_MOVE_SNAKE_ =  bitor(c.LABEL_DEST_PREFIX, idx);
FNC_MOVE_SNAKE  =  bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
FNC_READ_DIR_ =    bitor(c.LABEL_DEST_PREFIX, idx);
FNC_READ_DIR  =    bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DIR_LEFT_ =        bitor(c.LABEL_DEST_PREFIX, idx);
DIR_LEFT  =        bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DIR_RIGHT_ =       bitor(c.LABEL_DEST_PREFIX, idx);
DIR_RIGHT  =       bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DIR_UP_ =          bitor(c.LABEL_DEST_PREFIX, idx);
DIR_UP  =          bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DIR_DOWN_ =        bitor(c.LABEL_DEST_PREFIX, idx);
DIR_DOWN  =        bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DIR_SAVE_ =        bitor(c.LABEL_DEST_PREFIX, idx);
DIR_SAVE  =        bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
DIR_EXIT_ =        bitor(c.LABEL_DEST_PREFIX, idx);
DIR_EXIT  =        bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
MAIN_LOOP_ =       bitor(c.LABEL_DEST_PREFIX, idx);
MAIN_LOOP  =       bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
MOVE_LOOP_ =       bitor(c.LABEL_DEST_PREFIX, idx);
MOVE_LOOP  =       bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
FNC_CHECK_ =       bitor(c.LABEL_DEST_PREFIX, idx);
FNC_CHECK  =       bitor(c.LABEL_SRC_PREFIX,  idx);

idx = idx + 1;
CHECK_EXIT_ =      bitor(c.LABEL_DEST_PREFIX, idx);
CHECK_EXIT  =      bitor(c.LABEL_SRC_PREFIX,  idx);

c.LBL_CNT = idx;


p_tail_addr    = c.RAM_START + 0;

% Address of snake`s direction.
ADDR_DIRECTION = c.RAM_START + 1;

% Address of the increase in X-axis.
ADDR_INCR_X    = c.RAM_START + 2;

% Address of the increase in Y-axis.
ADDR_INCR_Y    = c.RAM_START + 3;

% X-position of a point/pixel to take.
ADDR_POINT_X   = c.RAM_START + 4;

% Y-position of a point/pixel to take.
ADDR_POINT_Y   = c.RAM_START + 5;

% Address of snake`s head.
ADDR_HEAD      = c.RAM_START + 6;

% Initial address of snake`s tail.
ADDR_INIT_TAIL = c.RAM_START + 11;


SourceCode = ...
[
					MOVL			r0					7					... % Initial position of point/pixel to take.
					STOREI			m(ADDR_POINT_X)		r0					...
					MOVL			r1					8					...
					STOREI			m(ADDR_POINT_Y)		r1					...
					SPX1			r0					r1					...
																			...
					MOVL			r0					255					... % Init value of X-increment is -1.
					STOREI			m(ADDR_INCR_X)		r0					...
					MOVL			r0					ADDR_INIT_TAIL + 1	... % r0 points to one address behind the tail.
					STOREI			p_tail_addr			r0					... % Pointer to the snake`s tail (an address where the address of snake`s tail is stored).
					CALL			FNC_INIT_SNAKE							...
MAIN_LOOP_			CALL			FNC_DRAW_SNAKE							...
					CALL			FNC_READ_DIR							...
					CALL			FNC_ERASE_SNAKE							...
					CALL			FNC_MOVE_SNAKE							...
					CALL			FNC_CHECK								...
					JMP				MAIN_LOOP								...
																			...
																			...
																			...
																			...
FNC_DRAW_SNAKE_		PUSH			r0										...
					PUSH			r1										...
					PUSH			r2										...
					PUSH			r3										...
					LOADI			r3					m(p_tail_addr)		... % r3 points to one address behind the tail.
					MOVL			r0					ADDR_HEAD			... % r0 points to head address.
DRAW_LOOP_			LOAD			r1					m(r0)				... % r1 contains snake.x.
					ADDI			r0					1					...
					LOAD			r2					m(r0)				... % r2 contains snake.y.
					ADDI			r0					1					...
					SPX1			r1					r2					...
					CMP				r0					r3					...
					JNE				DRAW_LOOP								... % Loop until whole snake is drawn.
					POP				r3										...
					POP				r2										...
					POP				r1										... 
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_CHECK_			PUSH			r0										...
					PUSH			r1										...
					PUSH			r2										...
					PUSH			r3										...
					LOADI			r0					m(ADDR_POINT_X)		...
					LOADI			r1					m(ADDR_POINT_Y)		...
					LOADI			r2					m(ADDR_HEAD)		...
					LOADI			r3					m(ADDR_HEAD + 1)	...
																			...
					CMP				r0					r2					... % Check that snake reached next point.
					JNE				CHECK_EXIT								...
					CMP				r1					r3					...
					JNE				CHECK_EXIT								...
																			...
					LOADI			r0					m(p_tail_addr)		... % Increase snake`s length by 2.
					ADDI			r0					2					...
					STOREI			m(p_tail_addr)		r0					...
																			...
					LOADI			r1					m(p_tail_addr)		...
					ADDI			r0					255					... % r0 = r0 - 1; r0 points to tail (X-pos);
					ADDI			r1					253					... % r1 = r1 - 3;
					LOAD			r2					m(r1)				...
					STORE			m(r0)				r2					...
					ADDI			r0					255					... % r0 = r0 - 1;
					ADDI			r1					255					... % r1 = r1 - 1;
					LOAD			r2					m(r1)				...
					STORE			m(r0)				r2					...
																			...
CHECK_EXIT_			POP				r3										...
					POP				r2										...
					POP				r1										...
					POP				r0										...
					RET														...
																			...
																			...
					ADDI			r0					0					...
					ADDI			r0					0					...
																			...
																			...
FNC_ERASE_SNAKE_	PUSH			r0										...
					PUSH			r1										...
					PUSH			r2										...
					PUSH			r3										...
					LOADI			r3					m(p_tail_addr)		... % r3 points to one address behind the tail.
					MOVL			r0					ADDR_HEAD			... % r0 points to head address.
ERASE_LOOP_			LOAD			r1					m(r0)				... % r1 contains snake.x.
					ADDI			r0					1					...
					LOAD			r2					m(r0)				... % r2 contains snake.y.
					ADDI			r0					1					...
					SPX0			r1					r2					...
					CMP				r0					r3					...
					JNE				ERASE_LOOP								... % Loop until whole snake is deleted.
					POP				r3										...
					POP				r2										...
					POP				r1										... 
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_ERASE_SCR_		PUSH			r0										... % X-position
					PUSH			r1										... % Y-position
					MOVL			r1					(MAX_Y + 1)			...
UPCOL_				ADDI			r1					255					... % r1 = r1 - 1
					MOVL			r0					MIN_X				...
UPROW_				SPX1			r0					r1					...
					ADDI			r0					1					...
					CMPI			r0					(MAX_X + 1)			...
					JNE				UPROW									...
					CMPI			r1					MIN_Y				...
					JNE				UPCOL									...
					MOVL			r1					0					...
DNCOL_				MOVL			r0					MIN_X				...
DNROW_				SPX0			r0					r1					...
					ADDI			r0					1					...
					CMPI			r0					(MAX_X + 1)			...
					JNE				DNROW									...
					ADDI			r1					1					...
					CMPI			r1					(MAX_Y + 1)			...
					JNE				DNCOL									...
					POP				r1										...
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_INIT_SNAKE_		PUSH			r0										... % Init snake to: [5,5], [5,6], [5,7].
					MOVL			r0					5					... % Initial position of snake`s head, the same value for both X and Y.
					STOREI			(ADDR_HEAD + 0)		r0					... % Save snake.x to RAM.
					STOREI			(ADDR_HEAD + 1)		r0					... % Save snake.y to RAM.
					STOREI			(ADDR_HEAD + 3)		r0					...
					STOREI			(ADDR_HEAD + 5)		r0					...
					MOVL			r0					6					...
					STOREI			(ADDR_HEAD + 2)		r0					...
					MOVL			r0					7					...
					STOREI			(ADDR_HEAD + 4)		r0					...
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_READ_DIR_		PUSH			r0										... % New direction (read from keyboard);
					PUSH			r1										... % X-increment.
					PUSH			r2										... % Y-increment / Old direction.
					LOADI			r2					m(ADDR_DIRECTION)	... % Read old direction from memory.
																			...
					GCH				r0										... % Read new direction from keyboard.
					CMPI			r0					BTN_2				...
					JPE				DIR_DOWN								... % Button 2 was pressed
					CMPI			r0					BTN_4				...
					JPE				DIR_LEFT								... % Button 4 was pressed
					CMPI			r0					BTN_6				...
					JPE				DIR_RIGHT								... % Button 6 was pressed
					CMPI			r0					BTN_8				...
					JPE				DIR_UP									... % Button 8 was pressed
					JMP				DIR_EXIT								...
																			...
DIR_LEFT_			CMPI			r2					BTN_6				... % Check that direction was not reverted (previous direction was opposite).
					JPE				DIR_EXIT								... % If direction was reverted then do nothing, jump to exit.
					MOVL			r1					255					... % X = -1
					MOVL			r2					0					... % Y =  0
					JMP				DIR_SAVE								...
																			...
DIR_RIGHT_			CMPI			r2					BTN_4				... % Check that direction was not reverted.
					JPE				DIR_EXIT								... % If direction was reverted then do nothing, jump to exit.
					MOVL			r1					1					... % X = +1
					MOVL			r2					0					... % Y =  0
					JMP				DIR_SAVE								...
																			...
DIR_UP_				CMPI			r2					BTN_2				... % Check that direction was not reverted.
					JPE				DIR_EXIT								... % If direction was reverted then do nothing, jump to exit.
					MOVL			r1					0					... % X =  0
					MOVL			r2					255					... % Y = -1
					JMP				DIR_SAVE								...
																			...
DIR_DOWN_			CMPI			r2					BTN_8				... % Check that direction was not reverted.
					JPE				DIR_EXIT								... % If direction was reverted then do nothing, jump to exit.
					MOVL			r1					0					... % X =  0
					MOVL			r2					1					... % Y = +1
																			...
DIR_SAVE_			STOREI			m(ADDR_INCR_X)		r1					... % Save new (current) X-increment to memory.
					STOREI			m(ADDR_INCR_Y)		r2					... % Save new (current) Y-increment to memory.
					STOREI			m(ADDR_DIRECTION)	r0					...
																			...
DIR_EXIT_			POP				r2										...
					POP				r1										...
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_MOVE_SNAKE_		PUSH			r0										... % Buffer for data exchange.
					PUSH			r1										... % Pointer to snake`s old position.
					PUSH			r2										... % Pointer to snake`s new position.
																			...
					LOADI			r1					m(p_tail_addr)		... 
					LOADI			r2					m(p_tail_addr)		... 
					ADDI			r1					255					... % r1 = r1 - 1; r1 initially points to the tail (Y-position).
					ADDI			r2					253					... % r2 = r2 - 3; r2 initially points to two addresses before the tail (Y-position).
																			...
MOVE_LOOP_			LOAD			r0					m(r2)				... % Copy snake`s Y-position to r0.
					STORE			m(r1)				r0					... % Shift snake`s Y-position by one address.
					ADDI			r1					255					... % r1 = r1 - 1; Shift to X-position;
					ADDI			r2					255					... % r2 = r2 - 1; Shift to X-position;
					LOAD			r0					m(r2)				... % Copy snake`s X-position to r0.
					STORE			m(r1)				r0					... % Shift snake`s X-position by one address.
					ADDI			r1					255					... % r1 = r1 - 1; Shift to Y-position;
					ADDI			r2					255					... % r2 = r2 - 1; Shift to Y-position;
					CMPI			r1					(ADDR_HEAD + 1)		...
					JNE				MOVE_LOOP								... % Loop until all snake (but head) is shifted.
																			...
					LOADI			r0					m(ADDR_INCR_X)		... % Update snake`s head X-positon based on new direction (X-increase).
					LOADI			r1					m(ADDR_HEAD)		...
					ADD				r1					r0					...
					STOREI			m(ADDR_HEAD)		r1					...
																			...
					LOADI			r0					m(ADDR_INCR_Y)		... % Update snake`s head Y-positon based on new direction (Y-increase).
					LOADI			r1					m(ADDR_HEAD + 1)	...
					ADD				r1					r0					... % ADD			r1			r0 -> este nemam implementovanu instrukciu load upper byte
					STOREI			m(ADDR_HEAD + 1)	r1					...
																			...
					POP				r2										...
					POP				r1										...
					POP				r0										...
					RET														...
																			...
																			...																
																			...
																			...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
					ADDI			r0			0							...
];

