
label = ...
{
	'LOOP',
	'LEFT',
	'RIGHT',
	'UP',
	'DOWN',
	'FNC_READ_KEY',
	'FNC_ERASE_SCR',
	'UPROW',
	'UPCOL',
	'DNROW',
	'DNCOL',
	'CONTINUE',
	'FNC_INIT_SNAKE',
	'FNC_DRAW_SNAKE',
	'FNC_ERASE_SNAKE',
	'DRAW_LOOP',
	'ERASE_LOOP',
	'FNC_MOVE_SNAKE',
	'FNC_READ_DIR',
	'DIR_LEFT',
	'DIR_RIGHT',
	'DIR_UP',
	'DIR_DOWN',
	'DIR_SAVE',
	'DIR_EXIT',
	'MAIN_LOOP',
	'MOVE_LOOP',
	'FNC_CHECK',
	'CHECK_EXIT'
};
for (idx = 1:size(label))
	eval([char(label(idx)),'  = bitor(c.LABEL_SRC_PREFIX,  idx);']);
	eval([char(label(idx)),'_ = bitor(c.LABEL_DEST_PREFIX, idx);']);
end
c.LBL_CNT = idx;


p_tail_addr    = c.RAM_START + 0;

% Address of snake`s direction.
ADDR_DIRECTION = c.RAM_START + 1;

% Address of the increase in X-axis.
ADDR_INCR_X    = c.RAM_START + 2;

% Address of the increase in Y-axis.
ADDR_INCR_Y    = c.RAM_START + 3;

% X-position of a point/pixel to take.
ADDR_POINT_X   = c.RAM_START + 4;

% Y-position of a point/pixel to take.
ADDR_POINT_Y   = c.RAM_START + 5;

% Address of snake`s head.
ADDR_HEAD      = c.RAM_START + 6;

% Initial address of snake`s tail.
ADDR_INIT_TAIL = c.RAM_START + 11;


SourceCode = ...
[
					MOVL			r0					7					... % Initial position of point/pixel to take.
					STOREI			m(ADDR_POINT_X)		r0					...
					MOVL			r1					8					...
					STOREI			m(ADDR_POINT_Y)		r1					...
					SPX1			r0					r1					...
																			...
					MOVL			r0					-1					... % Init value of X-increment.
					STOREI			m(ADDR_INCR_X)		r0					...
					MOVL			r0					ADDR_INIT_TAIL + 1	... % r0 points to one address behind the tail.
					STOREI			p_tail_addr			r0					... % Pointer to the snake`s tail (an address where the address of snake`s tail is stored).
					CALL			FNC_INIT_SNAKE							...
MAIN_LOOP_			CALL			FNC_DRAW_SNAKE							...
					CALL			FNC_READ_DIR							...
					CALL			FNC_ERASE_SNAKE							...
					CALL			FNC_MOVE_SNAKE							...
					CALL			FNC_CHECK								...
					JMP				MAIN_LOOP								...
																			...
																			...
																			...
																			...
FNC_DRAW_SNAKE_		PUSH			r0										...
					PUSH			r1										...
					PUSH			r2										...
					PUSH			r3										...
					LOADI			r3					m(p_tail_addr)		... % r3 points to one address behind the tail.
					MOVL			r0					ADDR_HEAD			... % r0 points to head address.
DRAW_LOOP_			LOAD			r1					m(r0)				... % r1 contains snake.x.
					ADDI			r0					1					...
					LOAD			r2					m(r0)				... % r2 contains snake.y.
					ADDI			r0					1					...
					SPX1			r1					r2					...
					CMP				r0					r3					...
					JNE				DRAW_LOOP								... % Loop until whole snake is drawn.
					POP				r3										...
					POP				r2										...
					POP				r1										... 
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_CHECK_			PUSH			r0										...
					PUSH			r1										...
					PUSH			r2										...
					PUSH			r3										...
					LOADI			r0					m(ADDR_POINT_X)		...
					LOADI			r1					m(ADDR_POINT_Y)		...
					LOADI			r2					m(ADDR_HEAD)		...
					LOADI			r3					m(ADDR_HEAD + 1)	...
																			...
					CMP				r0					r2					... % Check that snake reached next point.
					JNE				CHECK_EXIT								...
					CMP				r1					r3					...
					JNE				CHECK_EXIT								...
																			...
					LOADI			r0					m(p_tail_addr)		... % Increase snake`s length by 2.
					ADDI			r0					2					...
					STOREI			m(p_tail_addr)		r0					...
																			...
					LOADI			r1					m(p_tail_addr)		...
					ADDI			r0					-1					... % r0 points to tail (X-pos);
					ADDI			r1					-3					...
					LOAD			r2					m(r1)				...
					STORE			m(r0)				r2					...
					ADDI			r0					-1					...
					ADDI			r1					-1					...
					LOAD			r2					m(r1)				...
					STORE			m(r0)				r2					...
																			...
CHECK_EXIT_			POP				r3										...
					POP				r2										...
					POP				r1										...
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_ERASE_SNAKE_	PUSH			r0										...
					PUSH			r1										...
					PUSH			r2										...
					PUSH			r3										...
					LOADI			r3					m(p_tail_addr)		... % r3 points to one address behind the tail.
					MOVL			r0					ADDR_HEAD			... % r0 points to head address.
ERASE_LOOP_			LOAD			r1					m(r0)				... % r1 contains snake.x.
					ADDI			r0					1					...
					LOAD			r2					m(r0)				... % r2 contains snake.y.
					ADDI			r0					1					...
					SPX0			r1					r2					...
					CMP				r0					r3					...
					JNE				ERASE_LOOP								... % Loop until whole snake is deleted.
					POP				r3										...
					POP				r2										...
					POP				r1										... 
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_ERASE_SCR_		PUSH			r0										... % X-position
					PUSH			r1										... % Y-position
					MOVL			r1					(MAX_Y + 1)			...
UPCOL_				ADDI			r1					-1					...
					MOVL			r0					MIN_X				...
UPROW_				SPX1			r0					r1					...
					ADDI			r0					1					...
					CMPI			r0					(MAX_X + 1)			...
					JNE				UPROW									...
					CMPI			r1					MIN_Y				...
					JNE				UPCOL									...
					MOVL			r1					0					...
DNCOL_				MOVL			r0					MIN_X				...
DNROW_				SPX0			r0					r1					...
					ADDI			r0					1					...
					CMPI			r0					(MAX_X + 1)			...
					JNE				DNROW									...
					ADDI			r1					1					...
					CMPI			r1					(MAX_Y + 1)			...
					JNE				DNCOL									...
					POP				r1										...
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_INIT_SNAKE_		PUSH			r0										... % Init snake to: [5,5], [5,6], [5,7].
					MOVL			r0					5					... % Initial position of snake`s head, the same value for both X and Y.
					STOREI			(ADDR_HEAD + 0)		r0					... % Save snake.x to RAM.
					STOREI			(ADDR_HEAD + 1)		r0					... % Save snake.y to RAM.
					STOREI			(ADDR_HEAD + 3)		r0					...
					STOREI			(ADDR_HEAD + 5)		r0					...
					MOVL			r0					6					...
					STOREI			(ADDR_HEAD + 2)		r0					...
					MOVL			r0					7					...
					STOREI			(ADDR_HEAD + 4)		r0					...
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_READ_DIR_		PUSH			r0										... % New direction (read from keyboard);
					PUSH			r1										... % X-increment.
					PUSH			r2										... % Y-increment / Old direction.
					LOADI			r2					m(ADDR_DIRECTION)	... % Read old direction from memory.
																			...
					GCH				r0										... % Read new direction from keyboard.
					CMPI			r0					BTN_2				...
					JPE				DIR_DOWN								... % Button 2 was pressed
					CMPI			r0					BTN_4				...
					JPE				DIR_LEFT								... % Button 4 was pressed
					CMPI			r0					BTN_6				...
					JPE				DIR_RIGHT								... % Button 6 was pressed
					CMPI			r0					BTN_8				...
					JPE				DIR_UP									... % Button 8 was pressed
					JMP				DIR_EXIT								...
																			...
DIR_LEFT_			CMPI			r2					BTN_6				... % Check that direction was not reverted (previous direction was opposite).
					JPE				DIR_EXIT								... % If direction was reverted then do nothing, jump to exit.
					MOVL			r1					-1					... % X = -1
					MOVL			r2					0					... % Y =  0
					JMP				DIR_SAVE								...
																			...
DIR_RIGHT_			CMPI			r2					BTN_4				... % Check that direction was not reverted.
					JPE				DIR_EXIT								... % If direction was reverted then do nothing, jump to exit.
					MOVL			r1					1					... % X = +1
					MOVL			r2					0					... % Y =  0
					JMP				DIR_SAVE								...
																			...
DIR_UP_				CMPI			r2					BTN_2				... % Check that direction was not reverted.
					JPE				DIR_EXIT								... % If direction was reverted then do nothing, jump to exit.
					MOVL			r1					0					... % X =  0
					MOVL			r2					-1					... % Y = -1
					JMP				DIR_SAVE								...
																			...
DIR_DOWN_			CMPI			r2					BTN_8				... % Check that direction was not reverted.
					JPE				DIR_EXIT								... % If direction was reverted then do nothing, jump to exit.
					MOVL			r1					0					... % X =  0
					MOVL			r2					1					... % Y = +1
																			...
DIR_SAVE_			STOREI			m(ADDR_INCR_X)		r1					... % Save new (current) X-increment to memory.
					STOREI			m(ADDR_INCR_Y)		r2					... % Save new (current) Y-increment to memory.
					STOREI			m(ADDR_DIRECTION)	r0					...
																			...
DIR_EXIT_			POP				r2										...
					POP				r1										...
					POP				r0										...
					RET														...
																			...
																			...
																			...
																			...
FNC_MOVE_SNAKE_		PUSH			r0										... % Buffer for data exchange.
					PUSH			r1										... % Pointer to snake`s old position.
					PUSH			r2										... % Pointer to snake`s new position.
																			...
					LOADI			r1					m(p_tail_addr)		... 
					LOADI			r2					m(p_tail_addr)		... 
					ADDI			r1					-1					... % r1 initially points to the tail (Y-position).
					ADDI			r2					-3					... % r2 initially points to two addresses before the tail (Y-position).
																			...
MOVE_LOOP_			LOAD			r0					m(r2)				... % Copy snake`s Y-position to r0.
					STORE			m(r1)				r0					... % Shift snake`s Y-position by one address.
					ADDI			r1					-1					... % r1 = r1 - 1; Shift to X-position;
					ADDI			r2					-1					... % Shift to X-position;
					LOAD			r0					m(r2)				... % Copy snake`s X-position to r0.
					STORE			m(r1)				r0					... % Shift snake`s X-position by one address.
					ADDI			r1					-1					... % Shift to Y-position;
					ADDI			r2					-1					... % Shift to Y-position;
					CMPI			r1					(ADDR_HEAD + 1)		...
					JNE				MOVE_LOOP								... % Loop until all snake (but head) is shifted.
																			...
					LOADI			r0					m(ADDR_INCR_X)		... % Update snake`s head X-positon based on new direction (X-increase).
					LOADI			r1					m(ADDR_HEAD)		...
					ADD				r1					r0					...
					STOREI			m(ADDR_HEAD)		r1					...
																			...
					LOADI			r0					m(ADDR_INCR_Y)		... % Update snake`s head Y-positon based on new direction (Y-increase).
					LOADI			r1					m(ADDR_HEAD + 1)	...
					ADD				r1					r0					... % ADD			r1			r0 -> este nemam implementovanu instrukciu load upper byte
					STOREI			m(ADDR_HEAD + 1)	r1					...
																			...
					POP				r2										...
					POP				r1										...
					POP				r0										...
					RET														...
																			...
																			...																
																			...
																			...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
					ADDI			r0					0					...
];

