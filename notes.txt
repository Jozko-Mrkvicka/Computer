#############################################
# Znaky
#############################################
16x16x8[B] = 256x8[B] = 2048[B]
..X.............
..X.............
..XX............
................
................
................
Toto je 16 znako
................
................
................
................
................
................
.......X....XX..
......XX....XX..
XXXX..X.........


8x8x8[B] = 64x8[B] = 512[B]
........
Toto je.
osem....
znakov..
........
........
........
........


1x32x8[B] = 256[B]
Tu je 32 znakov.................


#############################################
# Pixely
#############################################
16x16[p] = 2[B]x16 = 32[B]
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . X . . | . . . . . . . .
. . . . . X . . | . . . . . . . .
. . . . . X X . | . . . . . . . .
----------------+----------------
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . X . .
. . . . . . . . | . . . X X X X .
. . . . . . . . | . . . X X . . .
. . . . . . . . | X X X X X . . .
. . . . . . . X | X . . . . . . .
X X X X . . . X | X . . . . . . .


16x24[p] = 2[B]x24 = 48[B]
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
----------------+----------------
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . X . . | . . . . . . . .
. . . . . X . . | . . . . . . . .
. . . . . X X . | . . . . . . . .
----------------+----------------
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . X . .
. . . . . . . . | . . . X X X X .
. . . . . . . . | . . . X X . . .
. . . . . . . . | X X X X X . . .
. . . . . . . X | X . . . . . . .
X X X X . . . X | X . . . . . . .


16x32[p] = 2[B]x32 = 64[B]
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
----------------+----------------
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
----------------+----------------
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
----------------+----------------
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .
. . . . . . . . | . . . . . . . .





Immediate        -->         Register      <-->        Register            <-->             Memory
           MOVU r0 imm (->)            MOV r0 r1 (->)            STORE   a(r0)  r1    (->)
           MOVL r0 imm (->)            MOV r0 r1 (<-)            STOREI  a(10)  r1    (->)
                                                                 LOAD    r1     a(r0) (<-)      
                                                                 LOADI   r1     a(10) (<-)


#############################################
# Co treba urobit
#############################################
- Pridat do common kniznice bloky counter.
- Na jeden z GP registrov namapovat hardwarovy generator nahodnych cisel.
- Spojit graficku a textovu pamat s RAM pamatou.
- Pridat .data segment/.text segment -> Chyba mi mechanizmus na ukladanie datovych poli do zdrojoveho kodu. Ako nahardcodovat pole cisel do ROM, aby sa neinterpretovali ako instrukcie?? Myslim ze sa na to pouziva sekcia ".data". 
- Vytvorit "control unit" (zlucit uz existujuce bloky) aby pocitac pripominal von Neumannovu schemu.
- Zatial este nemam ziaden return value register pomocou ktoreho by funkcia vracala navratovu hodnotu.
- Pamat nie je nijak chranena. Napriklad s instrukciou JMP by sa malo dat skocit doprostred zasobniku. Vymysliet ochranu + hard faulty.
- Pridat zbernicu (adresova, datova, riadiaca).

Pridat nove veci:
	- Rozsirit ALU (left shift, right shift).
	- Automaticky ukladat argument registre a0 .. a3 na zasobnik pri vykonani instrukcie CALL
	- Automaticky ukladat return value register.
	- Pridat vstupy (tlacitka/klavesnicu) + zamysliet sa nad interruptami.
	- Pridat dalsie instrukcie (podla inych 8-bit procesorov).
	- Citacku diernych stitkov (bude postavena z optozavor).

Preprocessor:
	

- Clean-up:
	- Pridat do definicie instrukcii (Instructions.m) informaciu o tom ci je immediate hodnota interpretovana ako singed alebo unsigned.
	- Instructions.m
	- Spocitat pouzite bloky, zjednotit, zjednodusit.
	- Zbavit sa warningov.
	- Ucesat nazvy, zmenit typ pisma na Currier.
	- Pridat komentare.

- Testy
	- Dokoncit unit testy.
	- Pridat systemove testy - kazdu instrukciu otestovat samostatne.

- Firmware:
	- Tetris
	- Snake
	- Kalkulacku
	- Faktorial -> Budem musiet ukladat na zasobnik aj navratovu adresu (Return Address Register).
	- Funkciu ktora dostane argumenty adresa pola a dlzka pola, a vrati sucet prvkov v poli (vytvorit demonstracnu funkciu ktora by dostala parametre z hlavneho programu a vratila by hodnotu. Ide tu o to ze este stale uplne nechapem pracu s funkciami/parametrami).

GIT:
	- Obsolete library blocks deleted.
	- The Selector blocks added to Decoder library.
	- The Control Bus added.
